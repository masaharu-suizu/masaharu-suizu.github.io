### ソースコードレビュー観点チェックリスト

#### 0. 前提

コーディング規約に沿っているかなどの静的解析ツールやリンターが得意なものはそれに任せ、ツールでは賄えない部分をレビューする。


#### 1. 要件と機能の充足

* **チケット整合性:** 今回のタスク（チケット）の内容を確認し、要件を過不足なく満たしたコードになっているか。
* **テストの網羅性:** 実装コードに対する単体テストが含まれているか。特にレビュアーが懸念したエッジケースがテストケースとして網羅されているか。

#### 2. ロジックの堅牢性

コードを読みながら脳内で実行し、正常系以外の`挙動`と、`データの不確実性`を徹底的に確認する。

* **Nullableのハンドリング:**
 * 値が `null` や `undefined` になり得る場合、使用する前に必ずチェック（ガード節やオプショナルチェーン）を行っているか。
* 「ここは絶対 `null` にならないはず」という思い込みで、危険なアクセスをしていないか。


* **防御的記述（予防線）:**
  * 空文字、空配列などの「値は存在するが中身がない」ケースに対して、適切なガード処理が入っているか。
  * 外部からの入力値に対する検証（バリデーション）は適切か。


* **タイムアウトとリトライ:**
  * 外部通信時のタイムアウト値は明示的に設定されているか。
  * タイムアウト時のリトライ処理と、無限ループ防止の上限回数は設定されているか。


* **例外処理:**
  * 予期せぬエラー発生時、DBのトランザクションは正しくロールバックされるか。



#### 3. パフォーマンスとスケーラビリティ

データ量の増加を見越した、アプリケーションロジック内でのアルゴリズム選定を見る。

* **計算量の妥当性:**
  * 大きなデータを扱う検索ロジックにおいて、配列の全走査（線形探索 ）になっていないか。
  * 将来的なデータ増加に備え、ハッシュマップ（Dict/Set/連想配列）を用いた**キー検索**を採用しているか。
  * ループの中でさらに検索を行うような、計算量が爆発するロジックがないか。



#### 4. 可読性と保守性

未来の自分や他人が読んだ時のコストを下げ、変更に強いコードにする。

* **型定義とNull安全性:**
  * 変数が **「Nullable（Null許容）」か「必須（Non-nullable）」か** が型定義で明示されているか。
  * `any` 等で安全性を放棄せず、適切な型定義がなされているか。


* **命名（名は体を表す）:** ファイル名、クラス名、メソッド名、変数名が、処理内容や役割を正確に表しているか。
* **可読性:** ネストが深すぎたり、回りくどいロジックになっていないか。「頭の中ですっと流れる」コードか。
* **コミットの粒度:** 1つのコミットが「1つの意味ある変更（Atomic Commit）」に保たれており、履歴が追いやすいか。(`git bisect` が使いやすいように。かつ、コミット<->チケットの検索性が向上する。)

#### 5. セキュリティと観測性

* **脆弱性対策:** SQLインジェクション、XSS、クリックジャッキング等の基本的な脆弱性への対策漏れがないか。
* **サプライチェーン:** 新規に追加されたライブラリは安全か（メンテナンス状況や既知の脆弱性）。
* **ログ設計:**
  * 外部APIを叩いた際、その結果やエラー内容が追跡可能なログとして出力されているか。
  * エラーログは、発生時のコンテキスト（引数や状態）を含んでいるか。


